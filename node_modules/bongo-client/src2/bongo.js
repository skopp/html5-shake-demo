// Generated by CoffeeScript 1.3.3

/*
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@module: bongo-client
@author: Christopher Thorn <chris@koding.com>
*/


/*
@snippet.
@description: feature-detect the browser.
@todo: is there an improvement?
@foo
*/


(function() {
  var Bongo, EventEmitter, isBrowser,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  isBrowser = 'undefined' !== typeof window;

  /*
  @class: bongo (client)
  @description: client-side bongo.
  */


  EventEmitter = require('events').EventEmitter;

  Bongo = (function(_super) {
    var JsPath, Model, Scrubber, Store, Traverse, createBongoName, createId, dash, extend, race, sequence, slice, _ref, _ref1, _ref2;

    __extends(Bongo, _super);

    Traverse = require('traverse');

    createId = Bongo.createId = require('hat');

    JsPath = Bongo.JsPath = require('jspath');

    Bongo.dnodeProtocol = require('koding-dnode-protocol');

    _ref = Bongo.dnodeProtocol, Store = _ref.Store, Scrubber = _ref.Scrubber;

    Bongo.EventEmitter = EventEmitter;

    Model = Bongo.Model = require('./src/model');

    Model.prototype.mixin(require('./src/eventemitter/broker'));

    slice = [].slice;

    extend = require('./src/util').extend;

    _ref1 = require('sinkrow'), race = _ref1.race, sequence = _ref1.sequence, dash = _ref1.dash;

    _ref2 = require('sinkrow'), Bongo.daisy = _ref2.daisy, Bongo.dash = _ref2.dash, Bongo.sequence = _ref2.sequence, Bongo.race = _ref2.race, Bongo.future = _ref2.future;

    createBongoName = function() {
      return 'bongo.' + createId();
    };

    function Bongo(options) {
      var _this = this;
      this.mq = options.mq, this.getSessionToken = options.getSessionToken;
      this.bongoName = createBongoName();
      this.channelName = 'private-' + this.bongoName;
      this.localStore = new Store;
      this.remoteStore = new Store;
      this.updateInstanceChannel = this.mq.subscribe('updateInstances');
      this.readyState = 0;
      this.stack = [];
      this.on('newListener', function(event, listener) {
        if (event === 'ready' && _this.readyState === 1) {
          return process.nextTick(function() {
            _this.emit('ready');
            return _this.removeAllListeners('ready');
          });
        }
      });
    }

    Bongo.prototype.cacheable = require('./src/cacheable');

    Bongo.prototype.createRemoteApiShims = function(api) {
      var instance, name, options, shimmedApi, statik, _ref3;
      shimmedApi = {};
      for (name in api) {
        _ref3 = api[name], statik = _ref3.statik, instance = _ref3.instance, options = _ref3.options;
        shimmedApi[name] = this.createConstructor(name, statik, instance, options);
      }
      return shimmedApi;
    };

    Bongo.prototype.wrapStaticMethods = (function() {
      var optimizeThese;
      optimizeThese = ['on', 'off'];
      return function(constructor, constructorName, statik) {
        var bongo;
        bongo = this;
        return statik.forEach(function(method) {
          if (__indexOf.call(optimizeThese, method) >= 0) {
            method += '_';
          }
          return constructor[method] = function() {
            var rpc;
            rpc = {
              type: 'static',
              constructorName: constructorName,
              method: method
            };
            return bongo.send(rpc, [].slice.call(arguments));
          };
        });
      };
    })();

    Bongo.prototype.wrapInstanceMethods = (function() {
      var optimizeThese;
      optimizeThese = ['on', 'addListener', 'off', 'removeListener', 'save'];
      return function(constructor, constructorName, instance) {
        var bongo;
        bongo = this;
        return instance.forEach(function(method) {
          if (__indexOf.call(optimizeThese, method) >= 0) {
            method += '_';
          }
          return constructor.prototype[method] = function() {
            var data, id, rpc;
            id = this.getId();
            if (id == null) {
              data = this.data;
            }
            rpc = {
              type: 'instance',
              constructorName: constructorName,
              method: method,
              id: id,
              data: data
            };
            return bongo.send(rpc, [].slice.call(arguments));
          };
        });
      };
    })();

    Bongo.prototype.createConstructor = function(name, staticMethods, instanceMethods, options) {
      var ctor, konstructor, option, prop;
      konstructor = Function("return function " + name + " () {\n  this.init.apply(this, [].slice.call(arguments));\n  this.bongo_.constructorName = '" + name + "';\n}")();
      this.wrapStaticMethods(konstructor, name, staticMethods);
      ctor = function() {
        this.constructor = konstructor;
      };
      ctor.prototype = Model.prototype;
      for (prop in Model) {
        if (!__hasProp.call(Model, prop)) continue;
        konstructor[prop] = Model[prop];
      }
      konstructor.prototype = new ctor;
      konstructor.prototype.updateInstanceChannel = this.updateInstanceChannel;
      konstructor.__super__ = Model.prototype;
      for (option in options) {
        if (!__hasProp.call(options, option)) continue;
        konstructor[option] = options[option];
      }
      this.wrapInstanceMethods(konstructor, name, instanceMethods);
      return konstructor;
    };

    Bongo.prototype.getInstancesById = function() {};

    Bongo.prototype.getInstanceMethods = function() {
      return ['fetchApi', 'changeLoggedInState'];
    };

    Bongo.prototype.revive = function(obj) {
      var bongo;
      bongo = this;
      return new Traverse(obj).map(function(node) {
        var constructorName, instance, instanceId, konstructor, _ref3;
        if ((node != null ? node.bongo_ : void 0) != null) {
          _ref3 = node.bongo_, constructorName = _ref3.constructorName, instanceId = _ref3.instanceId;
          instance = bongo.getInstancesById(instanceId);
          if (instance != null) {
            return this.update(instance, true);
          }
          konstructor = bongo.api[node.bongo_.constructorName];
          if (konstructor == null) {
            return this.update(node);
          } else {
            return this.update(new konstructor(node));
          }
        } else {
          return this.update(node);
        }
      });
    };

    Bongo.prototype.reviveFromSnapshots = function(instances, callback) {
      var _this = this;
      return callback(null, instances.map(function(instance) {
        if (instance.snapshot != null) {
          return _this.revive(JSON.parse(instance.snapshot));
        }
      }));
    };

    Bongo.prototype.handleRequest = function(message) {
      var callback, method, revived, scrubber, unscrubbed,
        _this = this;
      if ((message != null ? message.method : void 0) === 'defineApi') {
        return this.defineApi(message["arguments"][0]);
      } else {
        method = message.method;
        scrubber = new Scrubber(this.localStore);
        unscrubbed = scrubber.unscrub(message, function(callbackId) {
          if (!_this.remoteStore.has(callbackId)) {
            _this.remoteStore.add(callbackId, function() {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              return _this.send(callbackId, args);
            });
          }
          return _this.remoteStore.get(callbackId);
        });
        revived = this.revive(unscrubbed);
        if (__indexOf.call(this.getInstanceMethods(), method) >= 0) {
          return this[method].apply(this, revived);
        } else if (!isNaN(+method)) {
          callback = this.localStore.get(method);
          return callback != null ? callback.apply(null, revived) : void 0;
        } else {
          return console.log(method);
        }
      }
    };

    Bongo.prototype.connect = function(callback) {
      var _this = this;
      this.channel = this.mq.subscribe(this.channelName);
      return this.channel.once('broker:subscription_succeeded', function() {
        _this.channel.on('server-message', _this.handleRequest.bind(_this));
        setTimeout(function() {
          return _this.channel.emit('client-join', _this.getSessionToken());
        }, 1000);
        _this.stack.forEach(function(fn) {
          return fn.call(_this);
        });
        return callback(null);
      });
    };

    Bongo.prototype.messageFailed = function(message) {
      return console.log('MESSAGE FAILED', message);
    };

    Bongo.prototype.getTimeout = function(message, clientTimeout) {
      if (clientTimeout == null) {
        clientTimeout = 5000;
      }
      return setTimeout(this.messageFailed.bind(this, message), clientTimeout);
    };

    Bongo.prototype.send = function(method, args) {
      var scrubber,
        _this = this;
      if (!Array.isArray(args)) {
        args = [args];
      }
      if (!this.channel) {
        throw new Error('No channel!');
      } else {
        scrubber = new Scrubber(this.localStore);
        return scrubber.scrub(args, function() {
          var message, messageString;
          message = scrubber.toDnodeProtocol();
          message.method = method;
          message.sessionToken = _this.getSessionToken();
          messageString = JSON.stringify(message);
          return _this.channel.emit('client-message', messageString);
        });
      }
    };

    Bongo.prototype.disconnect = function(callback) {};

    Bongo.prototype.defineApi = function(api) {
      this.api = this.createRemoteApiShims(api);
      this.readyState = 1;
      return this.emit('ready');
    };

    Bongo.prototype.changeLoggedInState = function(state) {
      return this.emit('loggedInStateChanged', state);
    };

    Bongo.prototype.fetchChannel = function(channelName, callback) {
      var channel;
      channel = this.mq.subscribe(channelName);
      return channel.on('broker:subscription_succeeded', function() {
        return callback(channel);
      });
    };

    Bongo.prototype.use = function(fn) {
      return this.stack.push(fn);
    };

    return Bongo;

  })(EventEmitter);

  if (!isBrowser && module) {
    module.exports = Bongo;
  } else {
    if (typeof window !== "undefined" && window !== null) {
      window['Bongo'] = Bongo;
    }
  }

}).call(this);
