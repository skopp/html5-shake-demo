###
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@module: bongo-client
@author: Christopher Thorn <chris@koding.com>
###
###
@snippet.
@description: feature-detect the browser.
@todo: is there an improvement?
@foo
###
isBrowser = 'undefined' isnt typeof window
###
@class: bongo (client)
@description: client-side bongo.
###
# core
{EventEmitter} = require 'events'

class Bongo extends EventEmitter
  # bongo     = new EventEmitter
  # contrib
  Traverse  = require 'traverse'
  createId  = @createId = require 'hat'

  JsPath    = @JsPath = require 'jspath'

  @dnodeProtocol = require 'koding-dnode-protocol'
  {Store, Scrubber} = @dnodeProtocol

  @EventEmitter = EventEmitter
  Model     = @Model = require './src/model'

  # mixin the event emitter for the AMQP broker
  Model::mixin require './src/eventemitter/broker'

  {slice} = []

  {extend} = require './src/util'
  
  {race, sequence, dash} = require 'sinkrow'
  {@daisy, @dash, @sequence, @race, @future} = require 'sinkrow'

  createBongoName =-> 'bongo.'+createId()

  constructor:(options)->
    {@mq, @getSessionToken} = options
    @bongoName    = createBongoName()
    @channelName  = 'private-'+@bongoName
    @localStore   = new Store
    @remoteStore  = new Store
    @updateInstanceChannel = @mq.subscribe 'updateInstances'
    @readyState   = 0
    @stack = []
    @on 'newListener', (event, listener)=>
      if event is 'ready' and @readyState is 1
        process.nextTick =>
          @emit 'ready'
          @removeAllListeners 'ready'
    # @on 'ready', => @auth()

  cacheable:require './src/cacheable'

  createRemoteApiShims:(api)->
    shimmedApi = {}
    for name, {statik, instance, options} of api
      shimmedApi[name] = @createConstructor name, statik, instance, options
    shimmedApi

  wrapStaticMethods:do ->
    optimizeThese = ['on','off']
    (constructor, constructorName, statik)->
      bongo = @
      statik.forEach (method)->
        method += '_' if method in optimizeThese
        constructor[method] =->
          rpc = {
            type: 'static'
            constructorName
            method
          }
          bongo.send rpc, [].slice.call arguments

  wrapInstanceMethods:do ->
    optimizeThese = ['on','addListener','off','removeListener','save']
    (constructor, constructorName, instance)->
      bongo = @
      instance.forEach (method)->
        method += '_' if method in optimizeThese
        constructor::[method] =->
          id = @getId()
          data = @data unless id?
          rpc = {
            type: 'instance'
            constructorName
            method
            id
            data
          }
          bongo.send rpc, [].slice.call arguments

  createConstructor:(name, staticMethods, instanceMethods, options)->
    konstructor = do Function """
      return function #{name} () {
        this.init.apply(this, [].slice.call(arguments));
        this.bongo_.constructorName = '#{name}';
      }
      """
    @wrapStaticMethods konstructor, name, staticMethods
    ctor = ->
      @constructor = konstructor
      return
    ctor:: = Model::
    konstructor[prop] = Model[prop] for own prop of Model
    konstructor:: = new ctor
    konstructor::updateInstanceChannel = @updateInstanceChannel
    konstructor.__super__ = Model::
    konstructor[option] = options[option] for own option of options
    @wrapInstanceMethods konstructor, name, instanceMethods
    konstructor

  getInstancesById:->

  getInstanceMethods:-> ['fetchApi', 'changeLoggedInState']

  revive:(obj)->
    bongo = @
    new Traverse(obj).map (node)->
      if node?.bongo_?
        {constructorName, instanceId} = node.bongo_
        instance = bongo.getInstancesById instanceId
        return @update instance, yes if instance?
        konstructor = bongo.api[node.bongo_.constructorName]
        unless konstructor?
          @update node
        else
          @update new konstructor(node)
      else
        @update node

  # auth:->
  #   @channel.emit 'client-auth', @getSessionToken()

  reviveFromSnapshots:(instances, callback)->
    callback null, instances.map (instance)=>
      @revive JSON.parse instance.snapshot if instance.snapshot?

  handleRequest:(message)->
#    if message.clientTimeout?
#      clearTimeout message.clientTimeout
#      console.log 'theres a timeout', message
    if message?.method is 'defineApi'
      @defineApi message.arguments[0]
    else
      {method} = message
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub message, (callbackId)=>
        unless @remoteStore.has(callbackId)
          @remoteStore.add callbackId, (args...)=>
            @send callbackId, args
        @remoteStore.get callbackId
      revived = @revive unscrubbed
      if method in @getInstanceMethods()
        @[method] revived...
      else unless isNaN +method
        callback = @localStore.get(method)
        callback?.apply null, revived
      else
        console.log method

  connect:(callback)->
    @channel = @mq.subscribe @channelName
    @channel.once 'broker:subscription_succeeded', =>
      @channel.on 'server-message', @handleRequest.bind(@)
      setTimeout =>
        @channel.emit 'client-join', @getSessionToken()
      , 1000
      # apply the middleware
      @stack.forEach (fn)=> fn.call @
      callback null

  messageFailed:(message)->
    console.log 'MESSAGE FAILED', message

  getTimeout:(message, clientTimeout=5000)->
    setTimeout @messageFailed.bind(@, message), clientTimeout

  send:(method, args)->
    args = [args] unless Array.isArray(args)
    unless @channel
      throw new Error 'No channel!'
    else
      scrubber = new Scrubber @localStore
      scrubber.scrub args, =>
        message = scrubber.toDnodeProtocol()
        message.method = method
        message.sessionToken = @getSessionToken()
        messageString = JSON.stringify(message)
        @channel.emit 'client-message', messageString

  disconnect:(callback)->

  defineApi:(api)->
    @api = @createRemoteApiShims api
    @readyState = 1
    @emit 'ready'

  changeLoggedInState:(state)->
    @emit 'loggedInStateChanged', state

  fetchChannel:(channelName, callback)->
    channel = @mq.subscribe channelName
    channel.on 'broker:subscription_succeeded', ->
      callback channel

  use:(fn)->
    @stack.push fn
    
if not isBrowser and module
  module.exports = Bongo
else 
  window?['Bongo'] = Bongo

#   @api = {}

#   instances_ = {}
  
#   loading_ = {}
  
#   getCancellableCallback_ = (callback)->
#     cancelled = no
#     kallback = (rest...)->
#       callback rest... unless cancelled
#     kallback.cancel = -> cancelled = yes
#     kallback
  
#   fetchChannel_ = (channelName, callback)->
#     callback = getCancellableCallback_ callback
#     channel = @channel channelName
#     if channel
#       callback channel, no
#     else
#       channel = @subscribe channelName
#       channel.on 'broker:subscription_succeeded', ->
#         console.log 'subscription succeeded'
#         callback channel, yes
#     setTimeout (->callback.cancel()), 1000
  
#   getModelLoader =(constructor, id)->
#     loading_[constructor.name] or= {}
#     loader = loading_[constructor.name][id] or= new ModelLoader(constructor, id)
  
#   @cacheable =do ->
#     handleSingle =(constructorName, _id, callback)->
#       # TODO: this implementation sucks; reimplement.
#       if 'string' is typeof constructorName
#         constructor = bongo.api[constructorName]
#       else if 'function' is typeof constructorName
#         constructor = constructorName
#       unless constructor
#         callback new Error "Unknown type #{constructorName}"
#       else
#         constructor.cache or= {}
#         if model = constructor.cache[_id]
#           callback null, model
#         else getModelLoader(constructor, _id).load (err, model)->
#           constructor.cache[_id] = model
#           callback err, model
#       return

#     handleBatch =(batch, callback)->
#       models = []
#       # collectItems = race (i, single, fin)->
#       #   {name, type, constructorName, id} = single
#       #   handleSingle type or name or constructorName, id, (err, model)->
#       #     if err
#       #       callback err
#       #     else
#       #       models[i] = model
#       #       fin()
#       # , -> callback null, models
#       # 
#       # collectItems(item) for item in batch
#       queue = batch.map (single, i)->->
#         {name, type, constructorName, id} = single
#         handleSingle type or name or constructorName, id, (err, model)->
#           if err
#             callback err
#           else
#             models[i] = model
#             queue.fin()
#       dash queue, -> callback null, models
#       # return
#     ->
#       switch arguments.length
#         when 2
#           handleBatch.apply @, arguments
#         when 3
#           handleSingle.apply @, arguments
#         else
#           throw new Error 'bongo.cacheable expects either 2 or 3 arguments.'

#   @getInstances =-> instances_
  
#   @getInstancesById =(id)-> instances_[id]

#   @addReferences =(instances...)->
#     for instance in instances
#       unless '_id' of instance
#         throw new Error "Can't add a reference to an instance that has no id!"
#       instances_[instance._id] or= {}
#       instances_[instance._id][instance.bongo_.instanceId] = instance

#   unless isBrowser
#     @browserPath = "#{__dirname}/browser"

#   updateInstances =(data)->
#     constructor = @
#     instances = bongo.getInstancesById data._id
#     for own instanceId, instance of instances
#       instance[prop] = val for own prop, val of data
#       instance.emit 'update'

#   findMyInstance =do ->
#     hasEncoder = 'function' is typeof Encoder?.htmlEncode
#     (data, extend)->
#       instances = bongo.getInstancesById data._id
#       for own instanceId, instance of instances
#         if instanceId is data.bongo_.instanceId
#           new Traverse(data).forEach (node)->
#             if not @isLeaf and @path.length
#               if node.bongo_?
#                 JsPath.setAt instance, @path, findMyInstance(node)
#               else
#                 JsPath.setAt instance, @path, node
#             return
#           return instance
#       data = unless hasEncoder then data else new Traverse(data).forEach (node)->
#         if 'string' is typeof node
#           @update Encoder.htmlEncode node
#         else if @path.length and not @isLeaf and node.bongo_?.constructorName
#           @update findMyInstance(node), yes
#       model = new bongo.api[data.bongo_.constructorName] data

#   createConstructor =(name, staticMethods, instanceMethods, options)->
#     constructor = do Function """
#       return function #{name} () {
#         this.init.apply(this, [].slice.call(arguments));
#         this.bongo_.constructorName = '#{name}';
#       }
#       """
#     wrapStaticMethods constructor, staticMethods
#     ctor = ->
#       @constructor = constructor
#       return
#     ctor:: = Model::
#     constructor[prop] = Model[prop] for own prop of Model
#     constructor:: = new ctor
#     constructor.__super__ = Model::
#     constructor[option] = options[option] for option of options
#     wrapInstanceMethods constructor, instanceMethods
#     constructor

#   wrapStaticMethods = do ->
#     optimizeThese = ['on','off']
#     (constructor, staticMethods)->
#       for own methodName, method of staticMethods
#         do (methodName, method)->
#           methodName += '_' if methodName in optimizeThese
#           constructor[methodName] =(err, res)->
#             args = slice.call arguments
#             wrapAll args
#             if method.useMQ
#               channelId = createId()
#               channel = bongo.mq.subscribe channelId
#               channel.on 'broker:subscription_succeeded', ->
#                 method.apply constructor, [channelId].concat args
#             else
#               method.apply constructor, [null].concat args
#           constructor[methodName].useMQ = method.useMQ
#       return

#   wrapInstanceMethods = do ->
#     optimizeThese = ['on','addListener','off','removeListener','save']
#     (constructor, instanceMethods)->
#       for own methodName, method of instanceMethods
#         do (methodName, method)->
#           methodName += '_' if methodName in optimizeThese
#           constructor::[methodName] =->
#             args = slice.call arguments
#             wrapAll args
#             id = @getId()
#             if method.useMQ
#               channelId = 'private-'+createId()
#               channel = bongo.mq.subscribe channelId
#               channel.on 'broker:subscription_succeeded', ->
#                 method channelId, id, (@ unless id), args...
#             else
#               method null, id, (@ unless id), args... 
#             @
#           constructor::[methodName].useMQ = method.useMQ
#       return

#   wrapAll =(obj)->
#     new Traverse(obj).forEach (node)->
#       if 'function' is typeof node
#         @update wrapFn node
#     return

#   @reviveFromString =(str, callback)->
#     separator = str.indexOf ':'
#     strProtocol = str.substr 0, separator
#     strPaylod = str.substr separator + 1
#     try switch strProtocol
#       when 'json'
#         callback null, findMyInstance JSON.parse strPaylod
#       when 'feed'
#         instances = strPaylod.split('\n').map (json)->
#           findMyInstance JSON.parse json
#         callback null, instances
#     catch e then callback e
  
#   @reviveFromJSONP =(instances, callback)->
#     callback null, instances.map (instance)->
#       if instance.snapshot
#         findMyInstance JSON.parse instance.snapshot
#       else
#         console.log instance

#   wrapFn =(fn)->
#     (err, res)->
#       if res?.__channelId
#         channel = bongo.mq.channel res.__channelId
#         if channel?
#           channel.on 'message', fn.bind null, null
#           channel.on 'error', fn.bind null
#       else
#         args = slice.call(arguments)
#         wrapArgs args, (wrappedArgs)-> fn.apply @, wrappedArgs
#       @

#   wrapArgs =do->
#     jsonPrefix = /^json:/
#     feedPrefix = /^feed:/
#     {setAt} = JsPath
#     revive =(node)-> findMyInstance JSON.parse node.replace jsonPrefix, ''
#     (args, callback)->
#       parseThese = []
#       replaceThese = []
#       objectRefs = []
#       args = new Traverse(args).map (node)->
#         if 'string' is typeof node
#           if jsonPrefix.test node
#             parseThese.push {@path, node}
#             @update node
#           else if feedPrefix.test node
#             nodes = node.replace(feedPrefix, '').split '\n'
#             replaceThese.push {
#               @path
#               nodes
#             }
#             for child, i in nodes
#               parseThese.push {
#                 path: @path.concat i
#                 node: 'json:'+child
#               }
#             @update node
#           else @update node
#         else
#           if not @isLeaf and 'bongo_' of node and 'constructorName' of node.bongo_
#             if 'ObjectRef' is node.bongo_.constructorName
#               objectRefs.push {
#                 @path
#                 node
#               }
#             else
#               @update findMyInstance node
#           else
#             @update node

#       replaceThese.forEach ({path, nodes})->
#         nodes = (revive node for node in nodes)
#         setAt args, path, nodes

#       parseThese.forEach ({path, node})->
#         setAt args, path, revive node

#       return callback args unless objectRefs.length

#       objects = []
#       objectRefs.forEach (objectRef)->
#         objects.push ->
#           {constructorName, id} = objectRef.node
#           bongo.fetchInstance constructorName, id, (err, instance)->
#             throw err if err
#             setAt args, objectRef.path, instance
#             objects.fin()
#       dash objects, -> wrapArgs args, (args)-> callback args


#   clientId_ =
#     if localStorage?.clientId
#       localStorage.clientId
#     else
#       clientId_ = createId()
#       localStorage?.clientId = clientId_
#       clientId_

#   api = (remote, conn)->
    
#     receiveServerError:(errMsg)->
#       throw new Error "An error was reported by the server: "+errMsg
    
#     receiveAccessError:(errMsg)->
#       KD.requireLogin errMsg
    
#     fetchClientId:(callback)-> 
#       callback clientId_
    
#     receiveBroadcast:(broadcast)->
#       bongo.emit 'broadcast', broadcast

#   @connectKite =(options, callback =(kite)-> kite.emit 'ready')->
#     {name, kiteApi} = options
#     kiteApi.bongo_ = {name}
#     #kiteApi.bongo_.os = bongo.asynchronizeOwnMethods require 'os'
#     kiteApi.bongo_.id = clientId_
#     bongo.connect options, (api, conn)->
#       kite = new api.Kite kiteApi
#       callback kite, conn, api

#   stack = []
#   @use =(middleware)->
#     stack.push middleware
#     @
  
#   @connect =(port, callback)->
#     [callback, port] = [port, callback] unless callback
#     client = dnode api
#     client.stack = stack
#     client.connect port, (remote, conn)->
#       bongo.fetchInstance = remote.fetchInstance
#       remote.fetchApi (constructors, globals)->
#         for def in constructors
#           {
#             name
#             staticMethods
#             instanceMethods
#             rawStaticMethods
#             rawInstanceMethods
#             options
#           } = def
#           for methodName in rawStaticMethods
#             staticMethods[methodName].useMQ = yes
#           for methodName in rawInstanceMethods
#             instanceMethods[methodName].useMQ = yes
#           bongo.api[name] = createConstructor name, staticMethods, instanceMethods, options
#         callback bongo.api, conn
#     @
  
#   if window? and BONGO_MQ?
#     @mq = Model::mq = BONGO_MQ
#     @mq.fetchChannel = fetchChannel_.bind(@mq)
#     @mq.updateInstanceChannel = @mq.subscribe('updateInstance')
#     Model.wrapArgs = wrapArgs
#     Model::mixin require './src/eventemitter/broker'
#   else
#     Model::mixin require './src/eventemitter/dnode'
# ###
# @snippet.
# @description: export for node, or the browser, depending.
# ###