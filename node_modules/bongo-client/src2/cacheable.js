// Generated by CoffeeScript 1.3.3
(function() {
  var ModelLoader, dash, getModelLoader, handleBatch, handleSingle;

  ModelLoader = require('./modelloader');

  dash = require('sinkrow').dash;

  module.exports = function() {
    switch (arguments.length) {
      case 2:
        return handleBatch.apply(this, arguments);
      case 3:
        return handleSingle.apply(this, arguments);
      default:
        throw new Error('Bongo#cacheable expects either 2 or 3 arguments.');
    }
  };

  getModelLoader = (function() {
    var loading_;
    loading_ = {};
    return function(constructor, id) {
      var loader, _base, _name;
      loading_[_name = constructor.name] || (loading_[_name] = {});
      return loader = (_base = loading_[constructor.name])[id] || (_base[id] = new ModelLoader(constructor, id));
    };
  })();

  handleSingle = function(constructorName, _id, callback) {
    var constructor, model;
    if ('string' === typeof constructorName) {
      constructor = this.api[constructorName];
    } else if ('function' === typeof constructorName) {
      constructor = constructorName;
    }
    if (!constructor) {
      callback(new Error("Unknown type " + constructorName));
    } else {
      constructor.cache || (constructor.cache = {});
      if (model = constructor.cache[_id]) {
        callback(null, model);
      } else {
        getModelLoader(constructor, _id).load(function(err, model) {
          constructor.cache[_id] = model;
          return callback(err, model);
        });
      }
    }
  };

  handleBatch = function(batch, callback) {
    var models, queue,
      _this = this;
    models = [];
    queue = batch.map(function(single, i) {
      return function() {
        var constructorName, id, name, type;
        name = single.name, type = single.type, constructorName = single.constructorName, id = single.id;
        return handleSingle.call(_this, type || name || constructorName, id, function(err, model) {
          if (err) {
            return callback(err);
          } else {
            models[i] = model;
            return queue.fin();
          }
        });
      };
    });
    dash(queue, function() {
      return callback(null, models);
    });
  };

}).call(this);
