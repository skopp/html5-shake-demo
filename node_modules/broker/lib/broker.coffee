module.exports = class Broker
  amqp = require 'amqp'
  {dash} = require 'sinkrow'
  DELIMITER = 'Î»'

  constructor: (options) ->
    @options = options
    @eventMap = {}
    @connection = amqp.createConnection options
    @connection.on 'ready', => @readyState = 1
    @connection.setMaxListeners(0)
    @readyState = 0
    # @connection.on 'ready', callback if callback

  createExchange: (exchangeName, options, callback) ->
    if typeof options is 'function'
      callback = options
      options = {} 
    @ready =>

      options ?= {}
      options.durable ?= true
      options.autoDelete ?= true

      @connection.exchange exchangeName, options, callback

  createQueue: (queueName, options, callback) ->
    if typeof options is 'function'
      callback = options
      options = {durable:true, exclusive:true} 
    @ready =>
      @connection.queue queueName, options, callback

  funnel:(exchangeName, queueName)->
    @ready =>
      @createExchange exchangeName, (exchange)=>
        @createQueue queueName, {autoDelete:no}, (queue)=>
          queue.bind exchange, '#'
          @createQueue '', (dcQueue)->
            dcQueue.bind exchange, 'disconnected'
            dcQueue.subscribe ->
              queue.unbind exchange, '#'
              dcQueue.destroy()
  ###
  Bind exchange named 'destination' to exchange named 'source' on a
  routing key so that message come to 'source' exchange will flow to
  'destination' exchange if that message has the routing key.
  An auto-delete 'source' exchange will be removed if binding removed,
  but auto-delete 'destination' exchange will not.
  ###
  bindExchange: (destination, source, routingKey) ->
    @ready =>
      exchanges = {}
      exchangeOptions = durable: true
      queue = [
        createDestination = =>
          @createExchange destination, exchangeOptions, (exchange) ->
            exchanges.destination = exchange
            queue.fin()
        createSource = =>
          @createExchange source, exchangeOptions, (exchange) ->
            exchanges.source = exchange
            queue.fin()
      ]

      dash queue, ->
        exchanges.destination.bind exchanges.source, routingKey

  unbindExchange: (destination, source, routingKey) ->
    @ready =>
      destinationExchange = (@connection.exchanges or [])[destination]
      sourceExchange = (@connection.exchanges or [])[source]
      return unless destinationExchange? and sourceExchange?

      destinationExchange.unbind sourceExchange, routingKey

  bindQueue: (name, exchange, routing, options, callback) ->
    @ready =>
      options ?= {}
      {exchangeDurable, exchangeAutoDelete, queueDurable, queueExclusive} = options
      queueOptions =
        durable: unless queueDurable? then true else queueDurable 
        exclusive: unless queueExclusive? then true else queueExclusive

      unless exchange in (@connection.exchanges or [])
        exchangeOptions =
          durable: unless exchangeDurable? then true else exchangeDurable
          autoDelete: unless exchangeAutoDelete? then true else exchangeAutoDelete
        
        @createExchange exchange, exchangeOptions, =>
          @createQueue name, queueOptions, (queue) ->
            queue.bind exchange, routing
            queue.on 'queueBindOk', ->
              callback? queue, exchange
      else
        @createQueue name, queueOptions, (queue) ->
          queue.bind exchange, routing
          queue.on 'queueBindOk', ->
            callback? queue, exchange

  subscribe: (queueName, options, listener) ->
    @ready =>
      if 'function' is typeof queueName
        listener = queueName
        queueName = ''

      else if 'function' is typeof options
        listener = options
        options = {durable: true, exclusive: true}

      options ?= {}
      options.durable ?= true
      options.exclusive ?=true

      @createQueue queueName, options, (queue) ->
        result = queue.subscribe (payload, headers, deliveryInfo) ->
          message = payload.data+""
          if 'string' is typeof message
            listener message, headers, deliveryInfo
          else
            try 
              message = JSON.parse message
              listener message, headers, deliveryInfo
            catch e
              listener message: 'Parse error!'

  ready:(listener)->
    if @readyState is 1
      listener()
    else
      @connection.on 'ready', -> listener()

  emit: (channel, event, payload, options) ->
    @createExchange channel, (exchange) ->
      exchange.publish event, payload, options

  on: (channel, event, listener) ->
    # eventMap = @eventMap
    # key = channel+DELIMITER+event
    # return if eventMap[key]
    @ready =>
      unless channel in (@connection.exchanges or [])
        @createExchange channel, =>
          @subscribe listener
          @bindQueue '', channel, event
      else
        @subscribe listener
        @bindQueue '', channel, event

    # createQueue @connection, '', (queue) ->
    #     queue.bind channel, event
    #     queue.on 'queueBindOk', ->
    #         queue.subscribe (payload) ->
    #             console.log payload
    #             listener payload.data
    #         .addCallback (ok) ->
    #             ctag = ok.consumerTag
    #             eventMap[key] = [queue, ctag]

  off: (channel, event, listener) ->
    key = channel+DELIMITER+event
    [queue, ctag] = @eventMap[key]
    queue.unsubscribe(ctag)
    queue.destroy()

  # Alias
  trigger: @::emit
  bind: @::on
  unbind: @::off
