# lib
{castAll, convertComplexSelector} = require '../util'

###
@mixin: bongo "find" methods.
@description: Methods for selecting against the model's
  MongoDB collection.  You can mix this into constructors
  that have static methods with all of the following:
  @requiredSignature: SkinCollection obj.getCollection()
  @requiredSignature: obj.castValue(selector, constructor)
###
module.exports =

  drop:(callback)-> @getCollection().drop callback

  update:(selector, operation, options, callback)->
    [callback, options] = [options, callback] unless callback
    options or= {}
    @getCollection().update selector, operation, options, callback
    @

  assure:(selectorOrInitializer, callback)->
    constructor = @
    @one selectorOrInitializer, (err, inst)->
      if err
        callback err
      else if inst
        callback null, inst
      else
        callback null, new constructor selectorOrInitializer
    @

  one:(uniqueSelector, callback)->
    constructor = @
    collection = constructor.getCollection()
    collection.findOne castAll(uniqueSelector, constructor), (err, doc)->
      model = if not err and doc then new constructor doc
      callback err, model
    @

  all:(selector, callback)->
    constructor = @
    collection = constructor.getCollection()
    collection.find castAll(selector, constructor), (err, cursor)->
      if err
        callback err
      else
        cursor.toArray (err, docs)->
          callback null, docs?.map (doc)->
            new constructor doc
    @

  remove:(selector, callback)->
    [callback, selector] = [selector, callback] unless callback
    selector or= {}
    constructor = @
    collection = constructor.getCollection()
    collection.remove castAll(selector, constructor), {safe:yes}, callback
    @

  removeById:(_id, callback)->
    @remove {_id}, callback

  count:(selector, callback)->
    [callback, selector] = [selector, callback] unless callback
    selector or= {}
    constructor = @
    collection = constructor.getCollection()
    collection.count castAll(selector, constructor), callback
    @

  some:(selector, options, callback)->
    constructor = @
    collection = constructor.getCollection()

    delete options[name] for own name of options when not options[name]?

    collection.find castAll(selector, constructor), null, options, (err, cursor)->
      if err
        callback err
      else
        cursor.toArray (err, docs)->
          callback null, docs?.map (doc)->
            new constructor doc
    @

  someData: do ->
    ###
    @class: CursorDelegate
    @description: creates a proxy for a given cursor that has
      the critical methods bound as own-properties, which is
      handy for sharing the cursor with the client over dnode.
    ###
    class CursorDelegate
      methodNames = ['nextObject','each','toArray']
      constructor:(skinCursor)->
        {@totalNumberOfRecords} = skinCursor
        for methodName in methodNames
          @[methodName] = skinCursor[methodName].bind skinCursor
    ###
    @implementation.
    ###
    (selector, fields, options, callback)->
      [options, callback] = [callback, options] unless callback
      options or= {}
      constructor = @
      collection = constructor.getCollection()
      selector = castAll(selector, constructor)
      collection.find selector, fields, options, (err, cursor)->
        callback err, if cursor then new CursorDelegate cursor
      @

  hose:(rest...)-> @someData {}, rest...

  teasers:(selector, options, callback)->
    constructor = @
    throw new Error 'No defined teaser fields.' if not @teaserFields?
    [callback, options] = [options, callback] unless callback
    options or= {}
    @someData castAll(selector, constructor), @teaserFields, options, (err, cursor)->
      if err
        callback err
      else
        cursor.toArray (err, arr)->
          callback null, arr
    @

  mapReduce:(map, reduce, options, callback)->
    [callback, options] = [options, callback] unless callback
    options or= {}
    {wrapData} = options
    options.out or= inline: 1
    delete options.wrapData
    constructor = @
    collection = @getCollection()
    collection.mapReduce map, reduce, option, (err, collection)->
      collection.find (err, cursor)->
        cursor.toArray (err, docs)->
          callback \
            unless wrapData then docs
            else docs?.map (doc)-> new constructor doc
    @